"""Shared fixtures for E2E snapshot tests.

These fixtures set up the mock LLM server and agent configuration
for deterministic e2e testing with trajectory replay.
"""

import re
import shutil
import sys
import uuid as uuid_module
from collections.abc import Generator
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional

import pytest
from syrupy.extensions.single_file import SingleFileSnapshotExtension, WriteMode

from tests.conftest import create_test_agent_config
from tui_e2e.mock_llm_server import MockLLMServer
from tui_e2e.trajectory import get_trajectories_dir, load_trajectory


if TYPE_CHECKING:
    from syrupy.types import SerializableData, SerializedData


def normalize_svg(svg: str) -> str:
    """Strip the unique id generated by rich.Console.export_svg()."""
    return re.sub(r"\bterminal-\d+-([\w-]+)", r"terminal-\1", svg)


def normalize_svg_colors(svg: str) -> str:
    """Normalize SVG by remapping color classes to be deterministic.

    The Rich library assigns colors to CSS classes in the order they are
    first encountered during rendering. This order can vary between
    environments (local vs CI) due to differences in rendering order.

    This function:
    1. Strips the unique ID prefix (like normalize_svg)
    2. Extracts all color definitions and their class names
    3. Remaps class names based on sorted color values for determinism
    4. Updates all references to use the new class names
    5. Sorts the CSS definitions for consistent ordering
    """
    # First, strip the unique ID prefix
    svg = normalize_svg(svg)

    # Extract all color class definitions: .terminal-rN { fill: #XXXXXX }
    color_pattern = r"\.terminal-r(\d+) \{ fill: (#[0-9a-fA-F]+)(;[^}]*)? \}"
    color_matches = re.findall(color_pattern, svg)

    if not color_matches:
        return svg

    # Build a mapping of old class number -> (color, extra_styles)
    old_classes = {}
    for class_num, color, extra in color_matches:
        old_classes[class_num] = (color.lower(), extra)

    # Sort colors to create deterministic mapping
    # Group by (color, extra_styles) to handle font-weight etc.
    sorted_colors = sorted(
        old_classes.items(), key=lambda x: (x[1][0], x[1][1], int(x[0]))
    )

    # Create mapping from old class number to new class number
    class_mapping = {}
    new_class_defs = []
    for new_num, (old_num, (color, extra)) in enumerate(sorted_colors, start=1):
        class_mapping[old_num] = str(new_num)
        new_class_defs.append(f".terminal-r{new_num} {{ fill: {color}{extra} }}")

    # Remove old class definitions and insert new sorted ones
    def remove_class_defs(match):
        return ""

    svg = re.sub(color_pattern, remove_class_defs, svg)

    # Find where to insert the new class definitions
    style_match = re.search(r"(<style[^>]*>.*?)(</style>)", svg, re.DOTALL)
    if style_match:
        style_content = style_match.group(1)
        style_end = style_match.group(2)

        # Insert the new class definitions before </style>
        new_class_block = "\n    " + "\n".join(new_class_defs) + "\n    "
        svg = svg.replace(
            style_match.group(0), style_content + new_class_block + style_end
        )

    # Replace class references in the SVG content
    # Match class="terminal-rN" or class="terminal-XXXXX-rN"
    def replace_class_ref(match):
        old_num = match.group(1)
        new_num = class_mapping.get(old_num, old_num)
        return f'class="terminal-r{new_num}"'

    svg = re.sub(r'class="terminal-r(\d+)"', replace_class_ref, svg)

    return svg


class ColorNormalizedSVGExtension(SingleFileSnapshotExtension):
    """SVG snapshot extension that normalizes color class assignments.

    This extension ensures that SVG snapshots are deterministic across
    different environments by normalizing the color-to-class mappings.
    """

    _file_extension = "svg"
    _write_mode = WriteMode.TEXT

    def _read_snapshot_data_from_location(
        self, *args, **kwargs
    ) -> Optional["SerializableData"]:
        """Normalize SVG data right after they are loaded from persistent storage."""
        data = super()._read_snapshot_data_from_location(*args, **kwargs)
        if data is not None and isinstance(data, str):
            data = normalize_svg_colors(data)
        return data

    def serialize(self, *args, **kwargs) -> "SerializedData":
        """Normalize SVG data before comparison and persistence."""
        data = super().serialize(*args, **kwargs)
        if isinstance(data, str):
            return normalize_svg_colors(data)
        return data


@pytest.fixture
def snapshot(snapshot):
    """Override the default snapshot fixture to use color-normalized SVG extension."""
    return snapshot.use_extension(ColorNormalizedSVGExtension)


# Fixed work directory path - writable on most systems and deterministic for snapshots
WORK_DIR = Path("/tmp/openhands-e2e-test-workspace")

# Fixed conversation ID for deterministic snapshots
FIXED_CONVERSATION_ID = uuid_module.UUID("00000000-0000-0000-0000-000000000001")

# Fixed Python interpreter path for deterministic snapshots
FIXED_PYTHON_PATH = "/openhands/micromamba/envs/openhands/bin/python"

# Fixed OS description for deterministic snapshots
# (kernel version varies between environments)
FIXED_OS_DESCRIPTION = "Linux (kernel 6.0.0-test)"


class DeterministicUUIDGenerator:
    """Generator that returns sequential UUIDs for deterministic testing.

    Starts at 2 since conversation 1 is the initial FIXED_CONVERSATION_ID.
    """

    def __init__(self, start: int = 2):
        self._counter = start

    def __call__(self) -> uuid_module.UUID:
        """Return the next UUID in the sequence."""
        result = uuid_module.UUID(f"00000000-0000-0000-0000-{self._counter:012d}")
        self._counter += 1
        return result


@dataclass
class E2ETestEnvironment:
    """Container for e2e test environment paths."""

    persistence_dir: Path
    conversations_dir: Path
    work_dir: Path
    conversation_id: uuid_module.UUID


def setup_test_directories(tmp_path: Path) -> tuple[Path, Path]:
    """Create and return test directories.

    Returns:
        Tuple of (conversations_dir, work_dir)
    """
    conversations_dir = tmp_path / "conversations"
    conversations_dir.mkdir(exist_ok=True)

    if WORK_DIR.exists():
        shutil.rmtree(WORK_DIR)
    WORK_DIR.mkdir(parents=True, exist_ok=True)

    return conversations_dir, WORK_DIR


def patch_location_env_vars(
    monkeypatch: pytest.MonkeyPatch,
    tmp_path: Path,
    conversations_dir: Path,
    work_dir: Path,
) -> None:
    """Set environment variables for test paths.

    Using environment variables ensures all modules that call the getter functions
    will get the test paths, regardless of when they're imported.
    """
    monkeypatch.setenv("OPENHANDS_PERSISTENCE_DIR", str(tmp_path))
    monkeypatch.setenv("OPENHANDS_CONVERSATIONS_DIR", str(conversations_dir))
    monkeypatch.setenv("OPENHANDS_WORK_DIR", str(work_dir))


def patch_deterministic_paths(monkeypatch: pytest.MonkeyPatch) -> None:
    """Patch paths for deterministic snapshot testing.

    This ensures that sys.executable and Python interpreter paths are fixed
    to produce consistent snapshots across different environments.
    """
    # Mock sys.executable to return a fixed path for deterministic snapshots
    monkeypatch.setattr(sys, "executable", FIXED_PYTHON_PATH)

    # Patch the terminal metadata to use the fixed Python path
    # The terminal tool runs `command -v python` in the shell to get the path,
    # so we need to patch the from_ps1_match method to override the result
    try:
        from openhands.tools.terminal.metadata import CmdOutputMetadata

        original_from_ps1_match = CmdOutputMetadata.from_ps1_match

        @classmethod
        def patched_from_ps1_match(cls, match):
            result = original_from_ps1_match.__func__(cls, match)
            result.py_interpreter_path = FIXED_PYTHON_PATH
            return result

        monkeypatch.setattr(CmdOutputMetadata, "from_ps1_match", patched_from_ps1_match)
    except ImportError:
        pass  # If the module doesn't exist, skip patching

    # Patch get_os_description to return a fixed value
    # The kernel version varies between environments (CI vs local, different runners)
    # which causes snapshot mismatches
    try:
        import openhands_cli.utils

        monkeypatch.setattr(
            openhands_cli.utils, "get_os_description", lambda: FIXED_OS_DESCRIPTION
        )
    except ImportError:
        pass  # If the module doesn't exist, skip patching

    # Patch the LocalFileStore.create method to use deterministic conversation IDs
    # This ensures new conversations created via /new have predictable IDs
    # We patch the method directly rather than uuid.uuid4 to avoid affecting
    # other code that uses UUIDs (like event IDs)
    try:
        from openhands_cli.conversations.store.local import LocalFileStore

        original_create = LocalFileStore.create
        uuid_generator = DeterministicUUIDGenerator()

        def patched_create(self, conversation_id: str | None = None) -> str:
            if not conversation_id:
                conversation_id = uuid_generator().hex
            return original_create(self, conversation_id)

        monkeypatch.setattr(LocalFileStore, "create", patched_create)
    except (ImportError, AttributeError):
        pass  # If the module doesn't exist, skip patching

    # Patch AgentStore._build_agent_context to disable public skills loading
    # This ensures deterministic snapshots by not loading skills from the
    # public skills repository, which varies between environments
    try:
        from openhands.sdk.context import AgentContext
        from openhands_cli.stores.agent_store import AgentStore

        def patched_build_agent_context(self) -> AgentContext:
            from openhands.sdk.context.skills.skill import load_project_skills
            from openhands_cli.locations import get_work_dir
            from openhands_cli.utils import get_os_description

            skills = load_project_skills(get_work_dir())
            system_suffix = "\n".join(
                [
                    f"Your current working directory is: {get_work_dir()}",
                    f"User operating system: {get_os_description()}",
                ]
            )
            # Disable user/public skills for deterministic tests
            return AgentContext(
                skills=skills,
                system_message_suffix=system_suffix,
                load_user_skills=False,
                load_public_skills=False,
            )

        monkeypatch.setattr(
            AgentStore, "_build_agent_context", patched_build_agent_context
        )
    except (ImportError, AttributeError):
        pass  # If the module doesn't exist, skip patching


def cleanup_work_dir() -> None:
    """Clean up the fixed work directory."""
    if WORK_DIR.exists():
        shutil.rmtree(WORK_DIR)


# =============================================================================
# Base fixture - autouse for all e2e tests
# =============================================================================


@pytest.fixture(autouse=True)
def e2e_test_environment(
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
) -> Generator[E2ETestEnvironment, None, None]:
    """Base fixture that sets up the test environment for all e2e tests.

    This fixture is autouse=True, so it runs automatically for every test
    in the tests/snapshots/e2e/ directory. It:
    - Creates test directories (conversations, work)
    - Sets environment variables for test paths
    - Patches paths for deterministic snapshots

    Note: This only affects tests in tests/snapshots/e2e/ since conftest.py
    is scoped to this directory.
    """
    conversations_dir, work_dir = setup_test_directories(tmp_path)
    patch_location_env_vars(monkeypatch, tmp_path, conversations_dir, work_dir)
    patch_deterministic_paths(monkeypatch)

    yield E2ETestEnvironment(
        persistence_dir=tmp_path,
        conversations_dir=conversations_dir,
        work_dir=work_dir,
        conversation_id=FIXED_CONVERSATION_ID,
    )

    cleanup_work_dir()


# =============================================================================
# Specialized fixtures that build on the base environment
# =============================================================================


@pytest.fixture
def mock_llm_setup(
    e2e_test_environment: E2ETestEnvironment,
) -> Generator[dict[str, Any], None, None]:
    """Fixture that sets up mock LLM server with default trajectory.

    Uses 'simple_echo_hello_world' trajectory for deterministic replay.
    Returns a dict including 'conversation_id' that should be passed to OpenHandsApp.
    """
    trajectory = load_trajectory(get_trajectories_dir() / "simple_echo_hello_world")
    server = MockLLMServer(trajectory=trajectory)
    base_url = server.start()

    create_test_agent_config(
        e2e_test_environment.persistence_dir,
        model="openai/gpt-4o",
        base_url=base_url,
        expose_secrets=True,
    )

    yield {
        "persistence_dir": e2e_test_environment.persistence_dir,
        "conversations_dir": e2e_test_environment.conversations_dir,
        "mock_server_url": base_url,
        "work_dir": e2e_test_environment.work_dir,
        "trajectory": trajectory,
        "conversation_id": e2e_test_environment.conversation_id,
    }

    server.stop()


@pytest.fixture
def mock_llm_with_trajectory(
    e2e_test_environment: E2ETestEnvironment, request: pytest.FixtureRequest
) -> Generator[dict[str, Any], None, None]:
    """Fixture that sets up mock LLM server with a specified trajectory.

    Usage:
        @pytest.mark.parametrize("mock_llm_with_trajectory",
                                 ["simple_echo_hello_world"], indirect=True)
        def test_something(self, mock_llm_with_trajectory):
            ...

    Returns a dict including 'conversation_id' that should be passed to OpenHandsApp.
    """
    trajectory_name = getattr(request, "param", "simple_echo_hello_world")

    trajectory = load_trajectory(get_trajectories_dir() / trajectory_name)
    server = MockLLMServer(trajectory=trajectory)
    base_url = server.start()

    create_test_agent_config(
        e2e_test_environment.persistence_dir,
        model="openai/gpt-4o",
        base_url=base_url,
        expose_secrets=True,
    )

    yield {
        "persistence_dir": e2e_test_environment.persistence_dir,
        "conversations_dir": e2e_test_environment.conversations_dir,
        "mock_server_url": base_url,
        "work_dir": e2e_test_environment.work_dir,
        "trajectory": trajectory,
        "trajectory_name": trajectory_name,
        "conversation_id": e2e_test_environment.conversation_id,
    }

    server.stop()


@pytest.fixture
def first_time_user_setup(
    e2e_test_environment: E2ETestEnvironment,
) -> dict[str, Any]:
    """Fixture for testing first-time user experience (no agent configured).

    Unlike mock_llm_setup, this does NOT create agent_settings.json,
    simulating a user who has never configured the CLI before.
    """
    # NOTE: We intentionally do NOT call create_test_agent_config() here
    # to simulate a first-time user with no agent configured

    return {
        "persistence_dir": e2e_test_environment.persistence_dir,
        "conversations_dir": e2e_test_environment.conversations_dir,
        "work_dir": e2e_test_environment.work_dir,
        "conversation_id": e2e_test_environment.conversation_id,
    }
